uk24 <- uk24[, c(2, 3, 16, 17, 18)] |> mutate(year = 2024)
uk19 <- uk19[, c(2, 3, 16, 17, 18)] |> mutate(year = 2019)
uk17 <- uk17[, c(2, 3, 16, 17, 18)] |> mutate(year = 2017)
uk15 <- uk15[, c(2, 3, 16, 17, 18)] |> mutate(year = 2015)
uk10 <- uk10[, c(2, 3, 16, 17, 18)] |> mutate(year = 2010)
# Combine all into one
uk_all <- bind_rows(uk24, uk19, uk17, uk15, uk10)
### SPATIAL OVERLAY
uk_past <- uk_all %>%
filter(year %in% c(2010, 2015, 2017, 2019)) %>%
rename(PARL10 = `Constituency geographic code`)
View(uk_past)
merged <- uk_past %>%
inner_join(overlap, by = "PARL10") %>%
mutate(weighted_turnout = Turnout * percentage_overlap_pop)
## Libraries
library(rio)
library(dplyr)
# Load data
uk24 <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/only-turnout/turnout-general-election-04-07-2024.csv")
uk19 <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/only-turnout/turnout-general-election-12-12-2019.csv")
uk17 <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/only-turnout/turnout-general-election-08-06-2017.csv")
uk15 <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/only-turnout/turnout-general-election-07-05-2015.csv")
uk10 <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/only-turnout/turnout-general-election-06-05-2010.csv")
overlap <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/overlap/PARL25_PARL10_combo_overlap.csv") %>%
rename(PARL25 = PARL25, PARL10 = PARL10)
const <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/overlap/parl_constituencies_2025.csv")
# Select variables of interest
uk24 <- uk24[, c(2, 3, 16, 17, 18)] |> mutate(year = 2024)
uk19 <- uk19[, c(2, 3, 16, 17, 18)] |> mutate(year = 2019)
uk17 <- uk17[, c(2, 3, 16, 17, 18)] |> mutate(year = 2017)
uk15 <- uk15[, c(2, 3, 16, 17, 18)] |> mutate(year = 2015)
uk10 <- uk10[, c(2, 3, 16, 17, 18)] |> mutate(year = 2010)
# Combine all into one
uk_all <- bind_rows(uk24, uk19, uk17, uk15, uk10)
### SPATIAL OVERLAY
uk_past <- uk_all %>%
filter(year %in% c(2010, 2015, 2017, 2019)) %>%
rename(PARL10 = `Constituency geographic code`)
merged <- uk_past %>%
inner_join(overlap, by = "PARL10") %>%
mutate(weighted_turnout = Turnout * percentage_overlap_pop)
View(merged)
turnout_PARL25 <- merged %>%
group_by(year, PARL25) %>%
summarise(turnout_2024_constituency = sum(weighted_turnout, na.rm = TRUE)) %>%
ungroup()
View(turnout_PARL25)
library(rio)
library(dplyr)
library(corrplot)
library(GGally)
library(ggplot2)
library(sf)
library(spdep)
library(tidyr)
turnout <- import("/Users/alexander/Documents/MSc Data Science/erp-uom/data/ukTurnoutFULL.csv")
pcon_2024 <- st_read("/Users/alexander/Documents/MSc Data Science/erp-uom/shapefiles/2024/PCON_JULY_2024_UK_BFC.shp") # Open 2024 shp
# From long to wide format
df_wide <- turnout %>%
pivot_wider(
id_cols = c(gss_code, name),
names_from = year,
values_from = turnout_2024_constituency
) %>%
rename_with(
.cols = where(is.numeric),
.fn = ~ paste0("Y", .x)
)
turnout_years <- df_wide %>%
select(starts_with("Y")) %>% select(1,4,3,2,5)
plot_matrix <- ggpairs(
turnout_years,
lower = list(continuous = wrap("points", alpha = 0.3, size = 0.8)),
upper = list(continuous = wrap("cor", size = 3)),
diag = list(continuous = wrap("densityDiag", alpha = 0.5)),
title = "Turnout Scatterplot Matrix with Pearson Correlations"
)
# CLUSTERS
set.seed(42)
wss <- function(k) {
kmeans(turnout_years, centers = k, nstart = 10)$tot.withinss
}
k_values <- 1:10
wss_values <- sapply(k_values, wss)
plot(k_values, wss_values, type = "b", pch = 19,
xlab = "Number of Clusters (k)",
ylab = "Total Within-Cluster Sum of Squares",
main = "Elbow Method for Choosing Optimal k")
k <- 4
kmeans_result <- kmeans(turnout_years, centers = k, nstart = 25)
df_clustered <- df_wide %>% # Add cluster to data
filter(complete.cases(select(., starts_with("Y")))) %>%
mutate(cluster = kmeans_result$cluster)
View(df_clustered)
turnout_matrix <- df_wide %>%
select(starts_with("Y")) %>%
drop_na()
# Run PCA without scaling (since all are 0–1)
pca_result <- prcomp(turnout_matrix, center = TRUE, scale. = FALSE)
pca_df <- as.data.frame(pca_result$x[, 1:2]) %>%
mutate(cluster = factor(kmeans_result$cluster))
clust_turnout <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = cluster)) +
geom_point(alpha = 0.7, size = 2) +
labs(title = "Cluster Visualisation of Turnout Patterns (PCA)",
x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
scale_colour_brewer(palette = "Set1")
## Cluster Map
df_clustered %>%
group_by(cluster) %>%
summarise(across(starts_with("Y"), mean, na.rm = TRUE))
a <- df_clustered
a <- df_clustered %>%
group_by(cluster) %>%
summarise(across(starts_with("Y"), mean, na.rm = TRUE))
View(a)
2.208319e-65
library(rio)
library(dplyr)
library(corrplot)
library(GGally)
library(ggplot2)
library(sf)
library(spdep)
library(tidyr)
data <- import('/Users/alexander/Documents/MSc Data Science/erp-uom/data/dataTurnoutFinal.csv')
View(data)
# Only turnout
turnout <- data %>% select(1,7)
View(turnout)
# Only turnout
turnout <- data %>% select(1,2,7)
d
# From long to wide format
df_wide <- turnout %>%
pivot_wider(
id_cols = c(constituency_name),
names_from = election_year,
values_from = electoralTurnout
) %>%
rename_with(
.cols = where(is.numeric),
.fn = ~ paste0("Y", .x)
)
View(df_wide)
turnout_years <- df_wide %>%
turnout_years <- df_wide %>%
select(starts_with("Y"))
turnout_years <- df_wide %>% select(starts_with("Y"))
View(turnout_years)
plot_matrix <- ggpairs(
turnout_years,
lower = list(continuous = wrap("points", alpha = 0.3, size = 0.8)),
upper = list(continuous = wrap("cor", size = 3)),
diag = list(continuous = wrap("densityDiag", alpha = 0.5)),
title = "Turnout Scatterplot Matrix with Pearson Correlations"
)
ggsave("turnout_scatterplot_matrix.jpg",
plot = plot_matrix,
path = "/Users/alexander/Documents/GitHub/turnout-uk/figs",
width = 10, height = 10, dpi = 600)
# CLUSTERS
set.seed(42)
wss <- function(k) {
kmeans(turnout_years, centers = k, nstart = 10)$tot.withinss
}
k_values <- 1:10
wss_values <- sapply(k_values, wss)
plot(k_values, wss_values, type = "b", pch = 19,
xlab = "Number of Clusters (k)",
ylab = "Total Within-Cluster Sum of Squares",
main = "Elbow Method for Choosing Optimal k")
k <- 4
kmeans_result <- kmeans(turnout_years, centers = k, nstart = 25)
df_clustered <- df_wide %>% # Add cluster to data
filter(complete.cases(select(., starts_with("Y")))) %>%
mutate(cluster = kmeans_result$cluster)
turnout_matrix <- df_wide %>%
select(starts_with("Y")) %>%
drop_na()
# Run PCA without scaling (since all are 0–1)
pca_result <- prcomp(turnout_matrix, center = TRUE, scale. = FALSE)
pca_df <- as.data.frame(pca_result$x[, 1:2]) %>%
mutate(cluster = factor(kmeans_result$cluster))
clust_turnout <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = cluster)) +
geom_point(alpha = 0.7, size = 2) +
labs(title = "Cluster Visualisation of Turnout Patterns (PCA)",
x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
scale_colour_brewer(palette = "Set1")
clust_turnout <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = cluster)) +
geom_point(alpha = 0.7, size = 2) +
labs(title = "Cluster Visualisation of Turnout Patterns (PCA)",
x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
scale_colour_brewer(palette = "Set1")
ggsave("turnout_clusters_matrix.jpg",
plot = clust_turnout,
path = "/Users/alexander/Documents/GitHub/turnout-uk/figs",
width = 10, height = 10, dpi = 600)
d
## Cluster Map
df_clustered %>%
group_by(cluster) %>%
summarise(across(starts_with("Y"), mean, na.rm = TRUE))
View(df_clustered)
View(df_clustered)
## Cluster Map
df_clustered %>%
group_by(cluster) %>%
summarise(across(starts_with("Y"), mean, na.rm = TRUE))
## Cluster Map
df_clustered %>%
group_by(cluster) %>%
summarise(across(starts_with("Y"), mean, na.rm = TRUE))
df_clustered$cluster <- factor(df_clustered$cluster,
levels = 1:4,
labels = c("Low", "Medium - Low", "Medium - High", "High"),
ordered = TRUE)
pcon_2024_merged <- pcon_2024 %>% # Merge with shapefile
left_join(df_clustered, by = c("PCON24CD" = "gss_code"))
pcon_2010 <- st_read("/Users/alexander/Documents/MSc Data Science/erp-uom/shapefiles/2010/PCON_DEC_2020_UK_BFC.shp")
names(pcon_2010)
head(pcon_2010)
View(df_clustered)
data <- import('/Users/alexander/Documents/MSc Data Science/erp-uom/data/dataTurnoutFinal.csv')
pcon_2010 <- st_read("/Users/alexander/Documents/MSc Data Science/erp-uom/shapefiles/2010/PCON_DEC_2020_UK_BFC.shp")
View(data)
# Only turnout
turnout <- data %>% select(1,2,3,7)
# From long to wide format
df_wide <- turnout %>%
pivot_wider(
id_cols = c(constituency_name),
names_from = election_year,
values_from = electoralTurnout
) %>%
rename_with(
.cols = where(is.numeric),
.fn = ~ paste0("Y", .x)
)
View(df_wide)
View(turnout)
# From long to wide format
df_wide <- turnout %>%
pivot_wider(
id_cols = c(constituency_name, constituency_geographic_code),
names_from = election_year,
values_from = electoralTurnout
) %>%
rename_with(
.cols = where(is.numeric),
.fn = ~ paste0("Y", .x)
)
View(df_wide)
turnout_years <- df_wide %>% select(starts_with("Y"))
View(turnout_years)
plot_matrix <- ggpairs(
turnout_years,
lower = list(continuous = wrap("points", alpha = 0.3, size = 0.8)),
upper = list(continuous = wrap("cor", size = 3)),
diag = list(continuous = wrap("densityDiag", alpha = 0.5)),
title = "Turnout Scatterplot Matrix with Pearson Correlations"
)
ggsave("turnout_scatterplot_matrix.jpg",
plot = plot_matrix,
path = "/Users/alexander/Documents/GitHub/turnout-uk/figs",
width = 10, height = 10, dpi = 600)
# CLUSTERS
set.seed(42)
wss <- function(k) {
kmeans(turnout_years, centers = k, nstart = 10)$tot.withinss
}
k_values <- 1:10
wss_values <- sapply(k_values, wss)
plot(k_values, wss_values, type = "b", pch = 19,
xlab = "Number of Clusters (k)",
ylab = "Total Within-Cluster Sum of Squares",
main = "Elbow Method for Choosing Optimal k")
k <- 4
kmeans_result <- kmeans(turnout_years, centers = k, nstart = 25)
df_clustered <- df_wide %>% # Add cluster to data
filter(complete.cases(select(., starts_with("Y")))) %>%
mutate(cluster = kmeans_result$cluster)
turnout_matrix <- df_wide %>%
select(starts_with("Y")) %>%
drop_na()
# Run PCA without scaling (since all are 0–1)
pca_result <- prcomp(turnout_matrix, center = TRUE, scale. = FALSE)
pca_df <- as.data.frame(pca_result$x[, 1:2]) %>%
mutate(cluster = factor(kmeans_result$cluster))
clust_turnout <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = cluster)) +
geom_point(alpha = 0.7, size = 2) +
labs(title = "Cluster Visualisation of Turnout Patterns (PCA)",
x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
scale_colour_brewer(palette = "Set1")
ggsave("turnout_clusters_matrix.jpg",
plot = clust_turnout,
path = "/Users/alexander/Documents/GitHub/turnout-uk/figs",
width = 10, height = 10, dpi = 600)
## Cluster Map
df_clustered %>%
group_by(cluster) %>%
summarise(across(starts_with("Y"), mean, na.rm = TRUE))
df_clustered$cluster <- factor(df_clustered$cluster,
levels = 1:4,
labels = c("Low", "Medium - Low", "Medium - High", "High"),
ordered = TRUE)
View(df_clustered)
names(pcon_2010)
head(pcon_2010)
View(df_clustered)
pcon_2010 <- pcon_2010 %>% # Merge with shapefile
left_join(df_clustered, by = c("PCON20CD" = "constituency_geographic_code"))
head(pcon_2010)
colours <- c(
"High" = "#1A9850",
"Medium - High" = "#91CF60",
"Medium - Low" = "#FC8D59",
"Low"  = "#D73027"
)
cluster_map <- ggplot(pcon_2010) +
geom_sf(aes(fill = cluster), colour = "gray", size = 0.05) +
scale_fill_manual(
values = colours,
name = "Cluster of Turnout"
) +
labs(
title = "Spatial Patterns of Voter Turnout",
subtitle = "2010-2019",
caption = "Source: UK Parliament"
) +
theme_minimal() +
theme(
legend.position = "right",
panel.grid = element_blank(),
axis.text = element_blank(),
axis.title = element_blank()
)
# Save it
ggsave(
filename = "cluster_map.jpeg",
plot = cluster_map,
path = "/Users/alexander/Documents/GitHub/turnout-uk/figs",
width = 10,
height = 12,
dpi = 300
)
## Moran's I
# Define neighbours
nb <- poly2nb(pcon_2010)
# Step 2: Spatial weights matrix (row-standardised)
lw <- nb2listw(nb, style = "W", zero.policy = TRUE)
head(pcon_2010)
moran_2019 <- moran.test(pcon_2010$Y2019, lw, zero.policy = TRUE)
moran_2017 <- moran.test(pcon_2010$Y2017, lw, zero.policy = TRUE)
moran_2015 <- moran.test(pcon_2010$Y2015, lw, zero.policy = TRUE)
moran_2010 <- moran.test(pcon_2010$Y2010, lw, zero.policy = TRUE)
# Create a function to extract relevant info
extract_moran_info <- function(moran_obj, year) {
data.frame(
Year = year,
Moran_I = moran_obj$estimate[["Moran I statistic"]],
Expected_I = moran_obj$estimate[["Expectation"]],
Variance = moran_obj$estimate[["Variance"]],
P_value = moran_obj$p.value
)
}
moran_table <- rbind(
extract_moran_info(moran_2010, 2010),
extract_moran_info(moran_2015, 2015),
extract_moran_info(moran_2017, 2017),
extract_moran_info(moran_2019, 2019)
)
View(moran_table)
#### Visualise LISA
# Define election years
years <- c(2010, 2015, 2017, 2019)
# Loop through each year
for (year in years) {
# Extract turnout column name dynamically
turnout_col <- paste0("Y", year)
# Run local Moran's I
local <- localmoran(pcon_2024_merged[[turnout_col]], lw, zero.policy = TRUE)
# Add results to spatial object
pcon_2024_merged[[paste0("local_I_", year)]] <- local[, "Ii"]
pcon_2024_merged[[paste0("local_p_", year)]] <- local[, "Pr(z != E(Ii))"]
# Calculate spatial lag
lag_turnout <- lag.listw(lw, pcon_2024_merged[[turnout_col]])
pcon_2024_merged[[paste0("lag_Y", year)]] <- lag_turnout
# Get mean turnout for that year
mean_turnout <- mean(pcon_2024_merged[[turnout_col]], na.rm = TRUE)
# Create cluster classification
cluster_type <- case_when(
pcon_2024_merged[[turnout_col]] > mean_turnout &
lag_turnout > mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "High-High",
pcon_2024_merged[[turnout_col]] < mean_turnout &
lag_turnout < mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "Low-Low",
pcon_2024_merged[[turnout_col]] > mean_turnout &
lag_turnout < mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "High-Low",
pcon_2024_merged[[turnout_col]] < mean_turnout &
lag_turnout > mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "Low-High",
TRUE ~ "Not significant"
)
# Assign cluster type
cluster_col <- paste0("cluster_type_", year)
pcon_2024_merged[[cluster_col]] <- cluster_type
# Create and save the map
plot <- ggplot(pcon_2024_merged) +
geom_sf(aes(fill = .data[[cluster_col]]), color = "gray") +
scale_fill_manual(values = c(
"High-High" = "#e41a1c",
"Low-Low" = "#377eb8",
"High-Low" = "#984ea3",
"Low-High" = "#4daf4a",
"Not significant" = "grey80"
)) +
labs(
title = paste0("Local Moran’s I (LISA) Clusters – Turnout ", year),
fill = "Cluster Type",
caption = "Source: UK Parliament"
) +
theme_minimal() +
theme(
legend.position = "right",
panel.grid = element_blank(),
axis.text = element_blank(),
axis.title = element_blank()
)
# Save the plot
ggsave(
filename = paste0("lisa_", year, ".jpeg"),
plot = plot,
path = "//Users/alexander/Documents/GitHub/turnout-uk/figs",
width = 10,
height = 12,
dpi = 300
)
message("Saved LISA map for ", year)
}
# Loop through each year
for (year in years) {
# Extract turnout column name dynamically
turnout_col <- paste0("Y", year)
# Run local Moran's I
local <- localmoran(pcon_2010[[turnout_col]], lw, zero.policy = TRUE)
# Add results to spatial object
pcon_2010[[paste0("local_I_", year)]] <- local[, "Ii"]
pcon_2010[[paste0("local_p_", year)]] <- local[, "Pr(z != E(Ii))"]
# Calculate spatial lag
lag_turnout <- lag.listw(lw, pcon_2010[[turnout_col]])
pcon_2010[[paste0("lag_Y", year)]] <- lag_turnout
# Get mean turnout for that year
mean_turnout <- mean(pcon_2010[[turnout_col]], na.rm = TRUE)
# Create cluster classification
cluster_type <- case_when(
pcon_2010[[turnout_col]] > mean_turnout &
lag_turnout > mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "High-High",
pcon_2010[[turnout_col]] < mean_turnout &
lag_turnout < mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "Low-Low",
pcon_2010[[turnout_col]] > mean_turnout &
lag_turnout < mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "High-Low",
pcon_2010[[turnout_col]] < mean_turnout &
lag_turnout > mean_turnout &
local[, "Pr(z != E(Ii))"] < 0.05 ~ "Low-High",
TRUE ~ "Not significant"
)
# Assign cluster type
cluster_col <- paste0("cluster_type_", year)
pcon_2010[[cluster_col]] <- cluster_type
# Create and save the map
plot <- ggplot(pcon_2010) +
geom_sf(aes(fill = .data[[cluster_col]]), color = "gray") +
scale_fill_manual(values = c(
"High-High" = "#e41a1c",
"Low-Low" = "#377eb8",
"High-Low" = "#984ea3",
"Low-High" = "#4daf4a",
"Not significant" = "grey80"
)) +
labs(
title = paste0("Local Moran’s I (LISA) Clusters – Turnout ", year),
fill = "Cluster Type",
caption = "Source: UK Parliament"
) +
theme_minimal() +
theme(
legend.position = "right",
panel.grid = element_blank(),
axis.text = element_blank(),
axis.title = element_blank()
)
# Save the plot
ggsave(
filename = paste0("lisa_", year, ".jpeg"),
plot = plot,
path = "//Users/alexander/Documents/GitHub/turnout-uk/figs",
width = 10,
height = 12,
dpi = 300
)
message("Saved LISA map for ", year)
}
